import 'package:dart_mappable/dart_mappable.dart';
import 'package:editor/editor/document.dart';
import 'package:editor/services/websocket/models/lsp_autogenerated/language_server_protocol/lib/protocol_generated.dart';
import 'package:editor/services/websocket/models/server_class_defs/diff_change.dart';
import 'package:provider/provider.dart';

part 'message_types.mapper.dart';

sealed class Message {
  const Message({required this.content});
  final Map<String, dynamic> content;
}

@MappableEnum(caseStyle: CaseStyle.pascalCase)
enum ClientMessageType {
  openFile,
  closeFile,
  getDirectory,
  refreshDirectory,
  changeFile,
  saveFile,
  completion,
  hover,
  definition,
  createTerminal,
  resizeTerminal,
  writeTerminal,
  closeTerminal,
  createFile,
  deleteFile,
  renameFile,
  search,
  cancelSearch,
}

@MappableClass()
class ClientMessage extends Message with ClientMessageMappable {
  const ClientMessage({
    required this.type,
    required super.content,
  });
  final ClientMessageType type;

  // {path: uri}
  static Map<String, dynamic> getPathMap(String path) {
    return {'path': path};
  }

  // {document: {uri: uri, version: number}}
  static Map<String, dynamic> getDocumentMap(Document document) {
    return {
      'document': {
        'uri': document.docPath,
        'version': document.version,
      }
    };
  }

  // {path: string, position: Position}
  static Map<String, dynamic> getPositionPath(
      Document document, Position position) {
    return {'path': document.docPath, 'position': position.toJson()};
  }

  static ClientMessage openFile(Uri uri) {
    return ClientMessage(
      type: ClientMessageType.openFile,
      content: getPathMap(uri.toFilePath()),
    );
  }

  static ClientMessage closeFile(Document document) {
    return ClientMessage(
      type: ClientMessageType.closeFile,
      content: getPathMap(document.docPath),
    );
  }

  static ClientMessage getDirectory(Uri uri) {
    return ClientMessage(
      type: ClientMessageType.getDirectory,
      content: getPathMap(uri.toFilePath()),
    );
  }

  static ClientMessage getWorkingDirectory() {
    return const ClientMessage(
      type: ClientMessageType.getDirectory,
      content: {},
    );
  }

  static ClientMessage refreshDirectory(Uri uri) {
    return ClientMessage(
      type: ClientMessageType.refreshDirectory,
      content: getPathMap(uri.toFilePath()),
    );
  }

  static ClientMessage changeFile(Document document, List<DiffChange> changes) {
    final content = getDocumentMap(document);
    content.addEntries(
        [MapEntry('changes', changes.map((e) => e.toMap()).toList())]);
    return ClientMessage(
      type: ClientMessageType.changeFile,
      content: content,
    );
  }

  static ClientMessage saveFile(Document document) {
    final content = getDocumentMap(document);
    return ClientMessage(
      type: ClientMessageType.saveFile,
      content: content,
    );
  }

  static ClientMessage completion(Document document, Position position) {
    return ClientMessage(
      type: ClientMessageType.completion,
      content: getPositionPath(document, position),
    );
  }

  static ClientMessage hover(Document document, Position position) {
    return ClientMessage(
      type: ClientMessageType.hover,
      content: getPositionPath(document, position),
    );
  }

  static ClientMessage definition(Document document, Position position) {
    return ClientMessage(
      type: ClientMessageType.definition,
      content: getPositionPath(document, position),
    );
  }

  static ClientMessage createTerminal({required int cols, required int rows}) {
    return ClientMessage(
      type: ClientMessageType.createTerminal,
      content: {'rows': rows, 'cols': cols},
    );
  }

  static ClientMessage resizeTerminal(
      {required String termId, required int cols, required int rows}) {
    return ClientMessage(
      type: ClientMessageType.resizeTerminal,
      content: {'id': termId, 'rows': rows, 'cols': cols},
    );
  }

  static ClientMessage writeTerminal(
      {required String termId, required List<int> data}) {
    return ClientMessage(
      type: ClientMessageType.writeTerminal,
      content: {'id': termId, 'data': data},
    );
  }

  static ClientMessage closeTerminal({required String termId}) {
    return ClientMessage(
      type: ClientMessageType.closeTerminal,
      content: {'id': termId},
    );
  }

  static ClientMessage search(
      {required String query, bool searchContent = false}) {
    return ClientMessage(
      type: ClientMessageType.search,
      content: {'query': query, 'search_content': searchContent},
    );
  }

  static ClientMessage cancelSearch() {
    return const ClientMessage(
      type: ClientMessageType.cancelSearch,
      content: {},
    );
  }

  static ClientMessage renameFile({
    required String oldPath,
    required String newPath,
  }) {
    return ClientMessage(
      type: ClientMessageType.renameFile,
      content: {'old_path': oldPath, 'new_path': newPath},
    );
  }

  static ClientMessage deleteFile({
    required String path,
  }) {
    return ClientMessage(
      type: ClientMessageType.deleteFile,
      content: {
        'path': path,
      },
    );
  }

  static ClientMessage createFile({
    required String path,
  }) {
    return ClientMessage(
      type: ClientMessageType.renameFile,
      content: {'path': path, 'is_directory': false},
    );
  }

  /// Note: all 'directory' level functions use the same underlying message type
  /// as the 'file' level functions
  static ClientMessage renameDirectory({
    required String oldPath,
    required String newPath,
  }) {
    return ClientMessage(
      type: ClientMessageType.renameFile,
      content: {'old_path': oldPath, 'new_path': newPath},
    );
  }

  static ClientMessage deleteDirectory({
    required String path,
  }) {
    return ClientMessage(
      type: ClientMessageType.deleteFile,
      content: {
        'path': path,
      },
    );
  }

  static ClientMessage createDirectory({
    required String path,
  }) {
    return ClientMessage(
      type: ClientMessageType.renameFile,
      content: {'path': path, 'is_directory': true},
    );
  }
}

@MappableEnum(caseStyle: CaseStyle.pascalCase)
enum ServerMessageType {
  directoryContent,
  documentContent,
  documentPreview,
  documentChunk,
  fileSystemEvents,
  completionResponse,
  hoverResponse,
  definitionResponse,
  changeSuccess,
  saveSuccess,
  error,
  success,
  terminalCreated,
  terminalOutput,
  terminalClosed,
  terminalError,
  searchResults,
}

@MappableClass()
class ServerMessage extends Message with ServerMessageMappable {
  const ServerMessage({
    required this.type,
    required super.content,
  });
  final ServerMessageType type;
}
