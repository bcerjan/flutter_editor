import 'dart:async';
import 'dart:io';
import 'dart:convert';
import 'package:editor/services/websocket/models/lsp_autogenerated/language_server_protocol/lib/protocol_generated.dart';
import 'package:editor/services/websocket/models/server_class_defs/file_change_converter.dart';
import 'package:editor/services/websocket/models/server_class_defs/file_node.dart';
import 'package:editor/services/websocket/remote_provider.dart';
import 'package:path/path.dart' as _path;
import 'package:editor/services/explorer/filesystem.dart';
import 'package:editor/services/websocket/models/server_class_defs/message_types.dart';
import 'package:editor/services/websocket/remote_connection.dart';
import 'package:editor/services/websocket/websocket_connection.dart';

class RemoteFs<T extends RemoteConnection> extends ExplorerBackend<T> {
  RemoteFs();
  List<ExplorerListener> listeners = [];
  // List<FileSystemEntity> files = [];
  String rootPath = '';
  T? connection;

  /// Note: needs to be a broadcast stream to correctly handle sub-functions
  /// connecting/disconnecting from it
  StreamSubscription<ServerMessage>? sub;

  /// Root [FileNode] for the current working directory. Only changes on connect
  /// or disconnect. Note that the first directory content request should be
  /// the workspace directory (probably using
  /// [RemoteConnection.getWorkginDirectory])
  FileNode? workspace;

  @override
  void updateConnection(T? connection) {
    if (connection != null && connection.connected) {
      this.connection = connection;
      sub = connection.messages?.listen((msg) => fileEventMessageHandler(msg));
    } else {
      this.connection = null;
      workspace = null;
      rootPath = '';
      sub?.cancel();
    }
  }

  /// This always passes the root of the tree back to the [ExplorerListener]
  /// that owns this [RemoteFs]. That is where UI-type stuff like adjusting the
  /// displayed root occurs.
  void fileEventMessageHandler(ServerMessage msg) async {
    if (msg.type == ServerMessageType.fileSystemEvents) {
      final List<dynamic> events = msg.content['events'];
      for (final event in events) {
        final Map<String, dynamic> e = event as Map<String, dynamic>;
        final FileChangeType type = convert(e.keys.first); // should only be one
        final Map<String, dynamic> content =
            e.values.first as Map<String, dynamic>; // ""
        switch (type) {
          case FileChangeType.Changed:
            // Need to handle this elsewhere
            break;
          case FileChangeType.Created:
            // reload path at the location:
            // print(_path.dirname(_path.relative(Uri.file(content['path']).path,
            //     from: rootPath)));
            // loadPath(
            //     _path.dirname(_path.normalize(Uri.file(content['path']).path)));
            break;
          case FileChangeType.Deleted:
            for (final l in listeners) {
              l.onDelete({
                'path': _path.relative(Uri.file(content['path']).path,
                    from: rootPath)
              });
            }
            break;
        }
      }
    } else if (msg.type == ServerMessageType.directoryContent) {
      if (rootPath.isEmpty) {
        rootPath = msg.content['path'];
      }
      FileNode newTree = FileNode.fromServerDirectory(
        rootPath: msg.content['path'] ?? rootPath,
        jsonList: msg.content['content'],
      );

      if (workspace == null) {
        workspace ??= newTree;
      } else {
        newTree = await workspace!.populate(child: newTree);
      }

      for (final l in listeners) {
        l.onLoad(newTree);
      }
    }
  }

  @override
  void getWorkingDirectory() {
    checkConnection();
    connection!.getWorkingDirectory();
  }

  @override
  void addListener(ExplorerListener listener) {
    listeners.add(listener);
  }

  @override
  void setRootPath(String path) {
    rootPath = _path.normalize(path);
  }

  @override
  void createDirectory(String path) {
    checkConnection();
    connection!.createDirectory(path: path);
    // refreshDirectory(path: path);

    for (final l in listeners) {
      l.onCreate({'path': path});
    }
  }

  @override
  void createFile(String path) {
    checkConnection();
    connection!.createFile(path: path);
    // refreshDirectory(path: path);

    for (final l in listeners) {
      l.onCreate({'path': path});
    }
  }

  @override
  void deleteDirectory(String path, {bool recursive = false}) {
    checkConnection();
    connection!.deleteDirectory(path: path);
    // refreshDirectory(path: path);

    for (final l in listeners) {
      l.onDelete({'path': path});
    }
  }

  @override
  void deleteFile(String path) {
    checkConnection();
    connection!.deleteFile(path: path);
    // refreshDirectory(path: path);

    for (final l in listeners) {
      l.onDelete({'path': path});
    }
  }

  @override
  void loadPath(String path) async {
    checkConnection();
    connection!.getDirectory(path: _path.toUri(path));
  }

  @override
  void openFile(String path) async {
    /// This appears to be unused in this location, maybe only used somewhere else?
    // wsConnection.openFile(path: _path.toUri(path));

    // final ServerMessage msg = await msgStream
    //     .firstWhere((msg) => msg.type == ServerMessageType.documentContent);
  }

  @override
  void renameDirectory(String path, String newPath) {
    checkConnection();
    connection!.renameDirectory(oldPath: path, newPath: newPath);
    // refreshDirectory(path: path);
  }

  @override
  void renameFile(String path, String newPath) {
    checkConnection();
    connection!.renameFile(oldPath: path, newPath: newPath);
    // refreshDirectory(path: path);
  }

  @override

  /// Only searches filenames
  void search(String fileName) {
    checkConnection();
    // no command for searching within files in the override...
    connection!.search(search: fileName);
  }

  void refreshDirectory({String? path}) {
    path ??= rootPath;
    checkConnection();
    connection!.refreshDirectory(path: _path.toUri(path));
  }

  /// Searches filenames and content
  void contentSearch(String query) {
    checkConnection();
    connection!.search(search: query, searchContent: true);
  }

  void checkConnection() {
    if (connection == null || !connection!.connected || sub == null) {
      throw Exception('No connection established yet -- initialize first');
    }
  }

  void dispose() {
    sub?.cancel();
  }
}
