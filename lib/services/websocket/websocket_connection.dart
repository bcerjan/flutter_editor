import 'package:editor/editor/document.dart';
import 'package:editor/services/websocket/models/lsp_autogenerated/language_server_protocol/lib/protocol_generated.dart';
import 'package:editor/services/websocket/models/server_class_defs/diff_change.dart';
import 'package:editor/services/websocket/models/server_class_defs/message_types.dart';
import 'package:editor/services/websocket/remote_connection.dart';
import 'package:web_socket_channel/web_socket_channel.dart';
import 'package:dart_mappable/dart_mappable.dart';

part 'websocket_connection.mapper.dart';

@MappableClass()
class WebsocketConnection extends RemoteConnection
    with WebsocketConnectionMappable {
  WebsocketConnection();

  WebSocketChannel? channel;

  bool get connected => channel != null;

  /// Expects URL in the format: wss://a.b.c or ws://a.b.c
  @override
  Future<void> connect({required String serverUrl}) async {
    final uri = Uri.tryParse(serverUrl);
    if (uri != null) {
      try {
        channel = WebSocketChannel.connect(uri);
        await channel!.ready;
        // return channel!.stream
        //     .map((val) => ServerMessageMapper.fromJson(val as String));
        final stream = channel!.stream.asBroadcastStream();
        subscription = stream.listen((val) => print(val));
        messages = stream.map((val) {
          return ServerMessageMapper.fromJson(val);
        });
        return;
      } catch (e) {
        rethrow;
      }
    }

    throw WebSocketChannelException('Could not parse URL into a suitable URI');
  }

  @override
  void disconnect() {
    if (connected) {
      subscription!.cancel();
      channel!.sink.close();
    }
  }

  @override
  void openFile({required Uri path}) {
    checkConnection();
    channel!.sink.add(ClientMessage.openFile(path).toJson());
  }

  @override
  void closeFile({required Document document}) {
    checkConnection();
    channel!.sink.add(ClientMessage.closeFile(document).toJson());
  }

  @override
  void getDirectory({required Uri path}) {
    checkConnection();
    channel!.sink.add(ClientMessage.getDirectory(path).toJson());
  }

  @override
  void getWorkingDirectory() {
    checkConnection();
    channel!.sink.add(ClientMessage.getDirectory(Uri.file('')).toJson());
  }

  @override
  void refreshDirectory({required Uri path}) {
    checkConnection();
    channel!.sink.add(ClientMessage.refreshDirectory(path).toJson());
  }

  @override
  void changeFile(
      {required Document document, required List<DiffChange> changes}) {
    checkConnection();
    channel!.sink.add(ClientMessage.changeFile(document, changes).toJson());
  }

  @override
  void saveFile({required Document document}) {
    checkConnection();
    channel!.sink.add(ClientMessage.saveFile(document).toJson());
  }

  @override
  void completion({required Document document, required Position position}) {
    checkConnection();
    channel!.sink.add(ClientMessage.completion(document, position).toJson());
  }

  @override
  void hover({required Document document, required Position position}) {
    checkConnection();
    channel!.sink.add(ClientMessage.hover(document, position).toJson());
  }

  @override
  void definition({required Document document, required Position position}) {
    checkConnection();
    channel!.sink.add(ClientMessage.definition(document, position).toJson());
  }

  @override
  void cancelSearch() {
    checkConnection();
    channel!.sink.add(ClientMessage.cancelSearch().toJson());
  }

  @override
  void search({required String search, bool searchContent = false}) {
    checkConnection();
    cancelSearch(); // cancel any previous searches
    channel!.sink.add(ClientMessage.search(
      query: search,
      searchContent: searchContent,
    ).toJson());
  }

  @override
  void createDirectory({required String path}) {
    checkConnection();
    channel!.sink.add(ClientMessage.createDirectory(path: path));
  }

  @override
  void createFile({required String path}) {
    checkConnection();
    channel!.sink.add(ClientMessage.createFile(path: path));
  }

  @override
  void deleteDirectory({required String path}) {
    checkConnection();
    channel!.sink.add(ClientMessage.deleteDirectory(path: path));
  }

  @override
  void deleteFile({required String path}) {
    checkConnection();
    channel!.sink.add(ClientMessage.deleteFile(path: path));
  }

  @override
  void renameDirectory({required String oldPath, required String newPath}) {
    checkConnection();
    channel!.sink
        .add(ClientMessage.renameDirectory(oldPath: oldPath, newPath: newPath));
  }

  @override
  void renameFile({required String oldPath, required String newPath}) {
    checkConnection();
    channel!.sink
        .add(ClientMessage.renameFile(oldPath: oldPath, newPath: newPath));
  }

  void checkConnection() {
    if (channel == null) {
      throw WebSocketChannelException('No connection established yet');
    }
  }
}
