import 'package:dart_mappable/dart_mappable.dart';
import 'package:editor/editor/document.dart';
import 'package:editor/services/websocket/models/lsp_autogenerated/language_server_protocol/lib/protocol_generated.dart';
import 'package:editor/services/websocket/models/server_class_defs/diff_change.dart';

part 'message_types.mapper.dart';

sealed class Message {
  const Message({required this.content});
  final Map<String, dynamic> content;
}

@MappableEnum(caseStyle: CaseStyle.pascalCase)
enum ClientMessageType {
  openFile,
  closeFile,
  getDirectory,
  refreshDirectory,
  changeFile,
  saveFile,
  completion,
  hover,
  definition,
  createTerminal,
  resizeTerminal,
  writeTerminal,
  closeTerminal,
  search,
  cancelSearch,
}

@MappableClass()
class ClientMessage extends Message with ClientMessageMappable {
  const ClientMessage({
    required this.type,
    required super.content,
  });
  final ClientMessageType type;

  // {path: uri}
  static Map<String, dynamic> getPathMap(String path) {
    return {'path': path};
  }

  // {document: {uri: uri, version: number}}
  static Map<String, dynamic> getDocumentMap(Document document) {
    return {
      'document': {
        'uri': document.docPath,
        'version': document.documentId,
      }
    };
  }

  // {path: string, position: Position}
  static Map<String, dynamic> getPositionPath(
      Document document, Position position) {
    return {'path': document.docPath, 'position': position.toJson()};
  }

  static ClientMessage openFile(Uri uri) {
    return ClientMessage(
      type: ClientMessageType.openFile,
      content: getPathMap(uri.toFilePath()),
    );
  }

  static ClientMessage closeFile(Document document) {
    return ClientMessage(
      type: ClientMessageType.closeFile,
      content: getPathMap(document.docPath),
    );
  }

  static ClientMessage getDirectory(Uri uri) {
    return ClientMessage(
      type: ClientMessageType.getDirectory,
      content: getPathMap(uri.toFilePath()),
    );
  }

  static ClientMessage refreshDirectory(Uri uri) {
    return ClientMessage(
      type: ClientMessageType.refreshDirectory,
      content: getPathMap(uri.toFilePath()),
    );
  }

  static ClientMessage changeFile(Document document, List<DiffChange> changes) {
    final content = getDocumentMap(document);
    content.addEntries(
        [MapEntry('changes', changes.map((e) => e.toMap()).toList())]);
    return ClientMessage(
      type: ClientMessageType.changeFile,
      content: content,
    );
  }

  static ClientMessage saveFile(Document document) {
    final content = getDocumentMap(document);
    return ClientMessage(
      type: ClientMessageType.saveFile,
      content: content,
    );
  }

  static ClientMessage completion(Document document, Position position) {
    return ClientMessage(
      type: ClientMessageType.completion,
      content: getPositionPath(document, position),
    );
  }

  static ClientMessage hover(Document document, Position position) {
    return ClientMessage(
      type: ClientMessageType.hover,
      content: getPositionPath(document, position),
    );
  }

  static ClientMessage definition(Document document, Position position) {
    return ClientMessage(
      type: ClientMessageType.definition,
      content: getPositionPath(document, position),
    );
  }

  //TODO
  // static ClientMessage createTerminal({required int cols, required int rows}) {}
  // static ClientMessage resizeTerminal(
  //     {required String termId, required int cols, required int rows}) {}
  // static ClientMessage writeTerminal(
  //     {required String termId, required List<int> data}) {}
  // static ClientMessage closeTerminal({required String termId}) {}

  static ClientMessage search(
      {required String query, bool searchContent = false}) {
    return ClientMessage(
      type: ClientMessageType.search,
      content: {'query': query, 'search_content': searchContent},
    );
  }

  static ClientMessage cancelSearch() {
    return const ClientMessage(
      type: ClientMessageType.cancelSearch,
      content: {},
    );
  }
}

@MappableEnum(caseStyle: CaseStyle.pascalCase)
enum ServerMessageType {
  directoryContent,
  documentContent,
  fileSystemEvents,
  completionResponse,
  hoverResponse,
  definitionResponse,
  changeSuccess,
  saveSuccess,
  error,
  success,
  terminalCreated,
  terminalOutput,
  terminalClosed,
  terminalError,
  searchResults,
}

@MappableClass()
class ServerMessage extends Message with ServerMessageMappable {
  const ServerMessage({
    required this.type,
    required super.content,
  });
  final ServerMessageType type;
}
